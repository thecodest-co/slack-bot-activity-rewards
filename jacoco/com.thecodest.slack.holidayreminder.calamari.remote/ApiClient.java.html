<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ApiClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">holiday-reminder</a> &gt; <a href="index.source.html" class="el_package">com.thecodest.slack.activityrewards.calamari.remote</a> &gt; <span class="el_source">ApiClient.java</span></div><h1>ApiClient.java</h1><pre class="source lang-java linenums">/*
 * Calamari API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1
 * Contact: developers@calamari.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.thecodest.slack.holidayreminder.calamari.remote;

import com.squareup.okhttp.Call;
import com.squareup.okhttp.Callback;
import com.squareup.okhttp.FormEncodingBuilder;
import com.squareup.okhttp.Headers;
import com.squareup.okhttp.MediaType;
import com.squareup.okhttp.MultipartBuilder;
import com.squareup.okhttp.OkHttpClient;
import com.squareup.okhttp.Request;
import com.squareup.okhttp.RequestBody;
import com.squareup.okhttp.Response;
import com.squareup.okhttp.internal.http.HttpMethod;
import com.squareup.okhttp.logging.HttpLoggingInterceptor;
import com.squareup.okhttp.logging.HttpLoggingInterceptor.Level;
import com.thecodest.slack.holidayreminder.calamari.remote.auth.ApiKeyAuth;
import com.thecodest.slack.holidayreminder.calamari.remote.auth.Authentication;
import com.thecodest.slack.holidayreminder.calamari.remote.auth.HttpBasicAuth;
import com.thecodest.slack.holidayreminder.calamari.remote.auth.OAuth;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Type;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.GeneralSecurityException;
import java.security.KeyStore;
import java.security.SecureRandom;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.text.DateFormat;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.KeyManager;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;
import okio.BufferedSink;
import okio.Okio;

public class ApiClient {

<span class="fc" id="L75">	private final Map&lt;String, String&gt; defaultHeaderMap = new HashMap&lt;String, String&gt;();</span>
<span class="fc" id="L76">	private String basePath = &quot;https://thecodest.calamari.io/api&quot;;</span>
<span class="fc" id="L77">	private boolean debugging = false;</span>
<span class="fc" id="L78">	private String tempFolderPath = null;</span>

	private Map&lt;String, Authentication&gt; authentications;

	private DateFormat dateFormat;
	private DateFormat datetimeFormat;
	private boolean lenientDatetimeFormat;
	private int dateLength;

	private InputStream sslCaCert;
	private boolean verifyingSsl;
	private KeyManager[] keyManagers;

	private OkHttpClient httpClient;
	private JSON json;

	private HttpLoggingInterceptor loggingInterceptor;

	/*
	 * Constructor for ApiClient
	 */
<span class="fc" id="L99">	public ApiClient() {</span>
<span class="fc" id="L100">		httpClient = new OkHttpClient();</span>

<span class="fc" id="L102">		verifyingSsl = true;</span>

<span class="fc" id="L104">		json = new JSON();</span>

		// Set default User-Agent.
<span class="fc" id="L107">		setUserAgent(&quot;Swagger-Codegen/1.0.0/java&quot;);</span>

		// Setup authentications (key: authentication name, value: authentication).
<span class="fc" id="L110">		authentications = new HashMap&lt;String, Authentication&gt;();</span>
<span class="fc" id="L111">		authentications.put(&quot;basicAuth&quot;, new HttpBasicAuth());</span>
		// Prevent the authentications from being modified.
<span class="fc" id="L113">		authentications = Collections.unmodifiableMap(authentications);</span>
<span class="fc" id="L114">	}</span>

	/**
	 * Get base path
	 *
	 * @return Baes path
	 */
	public String getBasePath() {
<span class="nc" id="L122">		return basePath;</span>
	}

	/**
	 * Set base path
	 *
	 * @param basePath Base path of the URL (e.g https://thecodest.calamari.io/api
	 * @return An instance of OkHttpClient
	 */
	public ApiClient setBasePath(String basePath) {
<span class="nc" id="L132">		this.basePath = basePath;</span>
<span class="nc" id="L133">		return this;</span>
	}

	/**
	 * Get HTTP client
	 *
	 * @return An instance of OkHttpClient
	 */
	public OkHttpClient getHttpClient() {
<span class="nc" id="L142">		return httpClient;</span>
	}

	/**
	 * Set HTTP client
	 *
	 * @param httpClient An instance of OkHttpClient
	 * @return Api Client
	 */
	public ApiClient setHttpClient(OkHttpClient httpClient) {
<span class="nc" id="L152">		this.httpClient = httpClient;</span>
<span class="nc" id="L153">		return this;</span>
	}

	/**
	 * Get JSON
	 *
	 * @return JSON object
	 */
	public JSON getJSON() {
<span class="nc" id="L162">		return json;</span>
	}

	/**
	 * Set JSON
	 *
	 * @param json JSON object
	 * @return Api client
	 */
	public ApiClient setJSON(JSON json) {
<span class="nc" id="L172">		this.json = json;</span>
<span class="nc" id="L173">		return this;</span>
	}

	/**
	 * True if isVerifyingSsl flag is on
	 *
	 * @return True if isVerifySsl flag is on
	 */
	public boolean isVerifyingSsl() {
<span class="nc" id="L182">		return verifyingSsl;</span>
	}

	/**
	 * Configure whether to verify certificate and hostname when making https requests.
	 * Default to true.
	 * NOTE: Do NOT set to false in production code, otherwise you would face multiple types of cryptographic attacks.
	 *
	 * @param verifyingSsl True to verify TLS/SSL connection
	 * @return ApiClient
	 */
	public ApiClient setVerifyingSsl(boolean verifyingSsl) {
<span class="nc" id="L194">		this.verifyingSsl = verifyingSsl;</span>
<span class="nc" id="L195">		applySslSettings();</span>
<span class="nc" id="L196">		return this;</span>
	}

	/**
	 * Get SSL CA cert.
	 *
	 * @return Input stream to the SSL CA cert
	 */
	public InputStream getSslCaCert() {
<span class="nc" id="L205">		return sslCaCert;</span>
	}

	/**
	 * Configure the CA certificate to be trusted when making https requests.
	 * Use null to reset to default.
	 *
	 * @param sslCaCert input stream for SSL CA cert
	 * @return ApiClient
	 */
	public ApiClient setSslCaCert(InputStream sslCaCert) {
<span class="nc" id="L216">		this.sslCaCert = sslCaCert;</span>
<span class="nc" id="L217">		applySslSettings();</span>
<span class="nc" id="L218">		return this;</span>
	}

	public KeyManager[] getKeyManagers() {
<span class="nc" id="L222">		return keyManagers;</span>
	}

	/**
	 * Configure client keys to use for authorization in an SSL session.
	 * Use null to reset to default.
	 *
	 * @param managers The KeyManagers to use
	 * @return ApiClient
	 */
	public ApiClient setKeyManagers(KeyManager[] managers) {
<span class="nc" id="L233">		this.keyManagers = managers;</span>
<span class="nc" id="L234">		applySslSettings();</span>
<span class="nc" id="L235">		return this;</span>
	}

	public DateFormat getDateFormat() {
<span class="nc" id="L239">		return dateFormat;</span>
	}

	public ApiClient setDateFormat(DateFormat dateFormat) {
<span class="nc" id="L243">		this.json.setDateFormat(dateFormat);</span>
<span class="nc" id="L244">		return this;</span>
	}

	public ApiClient setSqlDateFormat(DateFormat dateFormat) {
<span class="nc" id="L248">		this.json.setSqlDateFormat(dateFormat);</span>
<span class="nc" id="L249">		return this;</span>
	}

	public ApiClient setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
<span class="nc" id="L253">		this.json.setOffsetDateTimeFormat(dateFormat);</span>
<span class="nc" id="L254">		return this;</span>
	}

	public ApiClient setLocalDateFormat(DateTimeFormatter dateFormat) {
<span class="nc" id="L258">		this.json.setLocalDateFormat(dateFormat);</span>
<span class="nc" id="L259">		return this;</span>
	}

	public ApiClient setLenientOnJson(boolean lenientOnJson) {
<span class="nc" id="L263">		this.json.setLenientOnJson(lenientOnJson);</span>
<span class="nc" id="L264">		return this;</span>
	}

	/**
	 * Get authentications (key: authentication name, value: authentication).
	 *
	 * @return Map of authentication objects
	 */
	public Map&lt;String, Authentication&gt; getAuthentications() {
<span class="nc" id="L273">		return authentications;</span>
	}

	/**
	 * Get authentication for the given name.
	 *
	 * @param authName The authentication name
	 * @return The authentication, null if not found
	 */
	public Authentication getAuthentication(String authName) {
<span class="nc" id="L283">		return authentications.get(authName);</span>
	}

	/**
	 * Helper method to set username for the first HTTP basic authentication.
	 *
	 * @param username Username
	 */
	public void setUsername(String username) {
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">		for(Authentication auth : authentications.values()) {</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">			if(auth instanceof HttpBasicAuth) {</span>
<span class="fc" id="L294">				((HttpBasicAuth) auth).setUsername(username);</span>
<span class="fc" id="L295">				return;</span>
			}
<span class="nc" id="L297">		}</span>
<span class="nc" id="L298">		throw new RuntimeException(&quot;No HTTP basic authentication configured!&quot;);</span>
	}

	/**
	 * Helper method to set password for the first HTTP basic authentication.
	 *
	 * @param password Password
	 */
	public void setPassword(String password) {
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">		for(Authentication auth : authentications.values()) {</span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">			if(auth instanceof HttpBasicAuth) {</span>
<span class="fc" id="L309">				((HttpBasicAuth) auth).setPassword(password);</span>
<span class="fc" id="L310">				return;</span>
			}
<span class="nc" id="L312">		}</span>
<span class="nc" id="L313">		throw new RuntimeException(&quot;No HTTP basic authentication configured!&quot;);</span>
	}

	/**
	 * Helper method to set API key value for the first API key authentication.
	 *
	 * @param apiKey API key
	 */
	public void setApiKey(String apiKey) {
<span class="nc bnc" id="L322" title="All 2 branches missed.">		for(Authentication auth : authentications.values()) {</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">			if(auth instanceof ApiKeyAuth) {</span>
<span class="nc" id="L324">				((ApiKeyAuth) auth).setApiKey(apiKey);</span>
<span class="nc" id="L325">				return;</span>
			}
<span class="nc" id="L327">		}</span>
<span class="nc" id="L328">		throw new RuntimeException(&quot;No API key authentication configured!&quot;);</span>
	}

	/**
	 * Helper method to set API key prefix for the first API key authentication.
	 *
	 * @param apiKeyPrefix API key prefix
	 */
	public void setApiKeyPrefix(String apiKeyPrefix) {
<span class="nc bnc" id="L337" title="All 2 branches missed.">		for(Authentication auth : authentications.values()) {</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">			if(auth instanceof ApiKeyAuth) {</span>
<span class="nc" id="L339">				((ApiKeyAuth) auth).setApiKeyPrefix(apiKeyPrefix);</span>
<span class="nc" id="L340">				return;</span>
			}
<span class="nc" id="L342">		}</span>
<span class="nc" id="L343">		throw new RuntimeException(&quot;No API key authentication configured!&quot;);</span>
	}

	/**
	 * Helper method to set access token for the first OAuth2 authentication.
	 *
	 * @param accessToken Access token
	 */
	public void setAccessToken(String accessToken) {
<span class="nc bnc" id="L352" title="All 2 branches missed.">		for(Authentication auth : authentications.values()) {</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">			if(auth instanceof OAuth) {</span>
<span class="nc" id="L354">				((OAuth) auth).setAccessToken(accessToken);</span>
<span class="nc" id="L355">				return;</span>
			}
<span class="nc" id="L357">		}</span>
<span class="nc" id="L358">		throw new RuntimeException(&quot;No OAuth2 authentication configured!&quot;);</span>
	}

	/**
	 * Set the User-Agent header's value (by adding to the default header map).
	 *
	 * @param userAgent HTTP request's user agent
	 * @return ApiClient
	 */
	public ApiClient setUserAgent(String userAgent) {
<span class="fc" id="L368">		addDefaultHeader(&quot;User-Agent&quot;, userAgent);</span>
<span class="fc" id="L369">		return this;</span>
	}

	/**
	 * Add a default header.
	 *
	 * @param key   The header's key
	 * @param value The header's value
	 * @return ApiClient
	 */
	public ApiClient addDefaultHeader(String key, String value) {
<span class="fc" id="L380">		defaultHeaderMap.put(key, value);</span>
<span class="fc" id="L381">		return this;</span>
	}

	/**
	 * Check that whether debugging is enabled for this API client.
	 *
	 * @return True if debugging is enabled, false otherwise.
	 */
	public boolean isDebugging() {
<span class="nc" id="L390">		return debugging;</span>
	}

	/**
	 * Enable/disable debugging for this API client.
	 *
	 * @param debugging To enable (true) or disable (false) debugging
	 * @return ApiClient
	 */
	public ApiClient setDebugging(boolean debugging) {
<span class="nc bnc" id="L400" title="All 2 branches missed.">		if(debugging != this.debugging) {</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">			if(debugging) {</span>
<span class="nc" id="L402">				loggingInterceptor = new HttpLoggingInterceptor();</span>
<span class="nc" id="L403">				loggingInterceptor.setLevel(Level.BODY);</span>
<span class="nc" id="L404">				httpClient.interceptors().add(loggingInterceptor);</span>
			} else {
<span class="nc" id="L406">				httpClient.interceptors().remove(loggingInterceptor);</span>
<span class="nc" id="L407">				loggingInterceptor = null;</span>
			}
		}
<span class="nc" id="L410">		this.debugging = debugging;</span>
<span class="nc" id="L411">		return this;</span>
	}

	/**
	 * The path of temporary folder used to store downloaded files from endpoints
	 * with file response. The default value is &lt;code&gt;null&lt;/code&gt;, i.e. using
	 * the system's default tempopary folder.
	 *
	 * @return Temporary folder path
	 * @see &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/io/File.html#createTempFile&quot;&gt;createTempFile&lt;/a&gt;
	 */
	public String getTempFolderPath() {
<span class="nc" id="L423">		return tempFolderPath;</span>
	}

	/**
	 * Set the temporary folder path (for downloading files)
	 *
	 * @param tempFolderPath Temporary folder path
	 * @return ApiClient
	 */
	public ApiClient setTempFolderPath(String tempFolderPath) {
<span class="nc" id="L433">		this.tempFolderPath = tempFolderPath;</span>
<span class="nc" id="L434">		return this;</span>
	}

	/**
	 * Get connection timeout (in milliseconds).
	 *
	 * @return Timeout in milliseconds
	 */
	public int getConnectTimeout() {
<span class="nc" id="L443">		return httpClient.getConnectTimeout();</span>
	}

	/**
	 * Sets the connect timeout (in milliseconds).
	 * A value of 0 means no timeout, otherwise values must be between 1 and
	 *
	 * @param connectionTimeout connection timeout in milliseconds
	 * @return Api client
	 */
	public ApiClient setConnectTimeout(int connectionTimeout) {
<span class="nc" id="L454">		httpClient.setConnectTimeout(connectionTimeout, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L455">		return this;</span>
	}

	/**
	 * Get read timeout (in milliseconds).
	 *
	 * @return Timeout in milliseconds
	 */
	public int getReadTimeout() {
<span class="nc" id="L464">		return httpClient.getReadTimeout();</span>
	}

	/**
	 * Sets the read timeout (in milliseconds).
	 * A value of 0 means no timeout, otherwise values must be between 1 and
	 * {@link Integer#MAX_VALUE}.
	 *
	 * @param readTimeout read timeout in milliseconds
	 * @return Api client
	 */
	public ApiClient setReadTimeout(int readTimeout) {
<span class="nc" id="L476">		httpClient.setReadTimeout(readTimeout, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L477">		return this;</span>
	}

	/**
	 * Get write timeout (in milliseconds).
	 *
	 * @return Timeout in milliseconds
	 */
	public int getWriteTimeout() {
<span class="nc" id="L486">		return httpClient.getWriteTimeout();</span>
	}

	/**
	 * Sets the write timeout (in milliseconds).
	 * A value of 0 means no timeout, otherwise values must be between 1 and
	 * {@link Integer#MAX_VALUE}.
	 *
	 * @param writeTimeout connection timeout in milliseconds
	 * @return Api client
	 */
	public ApiClient setWriteTimeout(int writeTimeout) {
<span class="nc" id="L498">		httpClient.setWriteTimeout(writeTimeout, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L499">		return this;</span>
	}

	/**
	 * Format the given parameter object into string.
	 *
	 * @param param Parameter
	 * @return String representation of the parameter
	 */
	public String parameterToString(Object param) {
<span class="nc bnc" id="L509" title="All 2 branches missed.">		if(param == null) {</span>
<span class="nc" id="L510">			return &quot;&quot;;</span>
<span class="nc bnc" id="L511" title="All 6 branches missed.">		} else if(param instanceof Date || param instanceof OffsetDateTime || param instanceof LocalDate) {</span>
			//Serialize to json string and remove the &quot; enclosing characters
<span class="nc" id="L513">			String jsonStr = json.serialize(param);</span>
<span class="nc" id="L514">			return jsonStr.substring(1, jsonStr.length() - 1);</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">		} else if(param instanceof Collection) {</span>
<span class="nc" id="L516">			StringBuilder b = new StringBuilder();</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">			for(Object o : (Collection) param) {</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">				if(b.length() &gt; 0) {</span>
<span class="nc" id="L519">					b.append(&quot;,&quot;);</span>
				}
<span class="nc" id="L521">				b.append(o);</span>
<span class="nc" id="L522">			}</span>
<span class="nc" id="L523">			return b.toString();</span>
		} else {
<span class="nc" id="L525">			return String.valueOf(param);</span>
		}
	}

	/**
	 * Formats the specified query parameter to a list containing a single {@code Pair} object.
	 * &lt;p&gt;
	 * Note that {@code value} must not be a collection.
	 *
	 * @param name  The name of the parameter.
	 * @param value The value of the parameter.
	 * @return A list containing a single {@code Pair} object.
	 */
	public List&lt;Pair&gt; parameterToPair(String name, Object value) {
<span class="nc" id="L539">		List&lt;Pair&gt; params = new ArrayList&lt;Pair&gt;();</span>

		// preconditions
<span class="nc bnc" id="L542" title="All 8 branches missed.">		if(name == null || name.isEmpty() || value == null || value instanceof Collection)</span>
<span class="nc" id="L543">			return params;</span>

<span class="nc" id="L545">		params.add(new Pair(name, parameterToString(value)));</span>
<span class="nc" id="L546">		return params;</span>
	}

	/**
	 * Formats the specified collection query parameters to a list of {@code Pair} objects.
	 * &lt;p&gt;
	 * Note that the values of each of the returned Pair objects are percent-encoded.
	 *
	 * @param collectionFormat The collection format of the parameter.
	 * @param name             The name of the parameter.
	 * @param value            The value of the parameter.
	 * @return A list of {@code Pair} objects.
	 */
	public List&lt;Pair&gt; parameterToPairs(String collectionFormat, String name, Collection value) {
<span class="nc" id="L560">		List&lt;Pair&gt; params = new ArrayList&lt;Pair&gt;();</span>

		// preconditions
<span class="nc bnc" id="L563" title="All 8 branches missed.">		if(name == null || name.isEmpty() || value == null || value.isEmpty()) {</span>
<span class="nc" id="L564">			return params;</span>
		}

		// create the params based on the collection format
<span class="nc bnc" id="L568" title="All 2 branches missed.">		if(&quot;multi&quot;.equals(collectionFormat)) {</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">			for(Object item : value) {</span>
<span class="nc" id="L570">				params.add(new Pair(name, escapeString(parameterToString(item))));</span>
<span class="nc" id="L571">			}</span>
<span class="nc" id="L572">			return params;</span>
		}

		// collectionFormat is assumed to be &quot;csv&quot; by default
<span class="nc" id="L576">		String delimiter = &quot;,&quot;;</span>

		// escape all delimiters except commas, which are URI reserved
		// characters
<span class="nc bnc" id="L580" title="All 2 branches missed.">		if(&quot;ssv&quot;.equals(collectionFormat)) {</span>
<span class="nc" id="L581">			delimiter = escapeString(&quot; &quot;);</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">		} else if(&quot;tsv&quot;.equals(collectionFormat)) {</span>
<span class="nc" id="L583">			delimiter = escapeString(&quot;\t&quot;);</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">		} else if(&quot;pipes&quot;.equals(collectionFormat)) {</span>
<span class="nc" id="L585">			delimiter = escapeString(&quot;|&quot;);</span>
		}

<span class="nc" id="L588">		StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">		for(Object item : value) {</span>
<span class="nc" id="L590">			sb.append(delimiter);</span>
<span class="nc" id="L591">			sb.append(escapeString(parameterToString(item)));</span>
<span class="nc" id="L592">		}</span>

<span class="nc" id="L594">		params.add(new Pair(name, sb.substring(delimiter.length())));</span>

<span class="nc" id="L596">		return params;</span>
	}

	/**
	 * Sanitize filename by removing path.
	 * e.g. ../../sun.gif becomes sun.gif
	 *
	 * @param filename The filename to be sanitized
	 * @return The sanitized filename
	 */
	public String sanitizeFilename(String filename) {
<span class="nc" id="L607">		return filename.replaceAll(&quot;.*[/\\\\]&quot;, &quot;&quot;);</span>
	}

	/**
	 * Check if the given MIME is a JSON MIME.
	 * JSON MIME examples:
	 * application/json
	 * application/json; charset=UTF8
	 * APPLICATION/JSON
	 * application/vnd.company+json
	 * &quot;* / *&quot; is also default to JSON
	 *
	 * @param mime MIME (Multipurpose Internet Mail Extensions)
	 * @return True if the given MIME is JSON, false otherwise.
	 */
	public boolean isJsonMime(String mime) {
<span class="nc" id="L623">		String jsonMime = &quot;(?i)^(application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(;.*)?$&quot;;</span>
<span class="nc bnc" id="L624" title="All 6 branches missed.">		return mime != null &amp;&amp; (mime.matches(jsonMime) || mime.equals(&quot;*/*&quot;));</span>
	}

	/**
	 * Select the Accept header's value from the given accepts array:
	 * if JSON exists in the given array, use it;
	 * otherwise use all of them (joining into a string)
	 *
	 * @param accepts The accepts array to select from
	 * @return The Accept header to use. If the given array is empty,
	 * null will be returned (not to set the Accept header explicitly).
	 */
	public String selectHeaderAccept(String[] accepts) {
<span class="nc bnc" id="L637" title="All 2 branches missed.">		if(accepts.length == 0) {</span>
<span class="nc" id="L638">			return null;</span>
		}
<span class="nc bnc" id="L640" title="All 2 branches missed.">		for(String accept : accepts) {</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">			if(isJsonMime(accept)) {</span>
<span class="nc" id="L642">				return accept;</span>
			}
		}
<span class="nc" id="L645">		return StringUtil.join(accepts, &quot;,&quot;);</span>
	}

	/**
	 * Select the Content-Type header's value from the given array:
	 * if JSON exists in the given array, use it;
	 * otherwise use the first one of the array.
	 *
	 * @param contentTypes The Content-Type array to select from
	 * @return The Content-Type header to use. If the given array is empty,
	 * or matches &quot;any&quot;, JSON will be used.
	 */
	public String selectHeaderContentType(String[] contentTypes) {
<span class="nc bnc" id="L658" title="All 4 branches missed.">		if(contentTypes.length == 0 || contentTypes[0].equals(&quot;*/*&quot;)) {</span>
<span class="nc" id="L659">			return &quot;application/json&quot;;</span>
		}
<span class="nc bnc" id="L661" title="All 2 branches missed.">		for(String contentType : contentTypes) {</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">			if(isJsonMime(contentType)) {</span>
<span class="nc" id="L663">				return contentType;</span>
			}
		}
<span class="nc" id="L666">		return contentTypes[0];</span>
	}

	/**
	 * Escape the given string to be used as URL query value.
	 *
	 * @param str String to be escaped
	 * @return Escaped string
	 */
	public String escapeString(String str) {
<span class="nc" id="L676">		return URLEncoder.encode(str, StandardCharsets.UTF_8).replaceAll(&quot;\\+&quot;, &quot;%20&quot;);</span>
	}

	/**
	 * Deserialize response body to Java object, according to the return type and
	 * the Content-Type response header.
	 *
	 * @param &lt;T&gt;        Type
	 * @param response   HTTP response
	 * @param returnType The type of the Java object
	 * @return The deserialized Java object
	 * @throws ApiException If fail to deserialize response body, i.e. cannot read response body
	 *                      or the Content-Type of the response is not supported.
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;T&gt; T deserialize(Response response, Type returnType) throws ApiException {
<span class="nc bnc" id="L692" title="All 4 branches missed.">		if(response == null || returnType == null) {</span>
<span class="nc" id="L693">			return null;</span>
		}

<span class="nc bnc" id="L696" title="All 2 branches missed.">		if(&quot;byte[]&quot;.equals(returnType.toString())) {</span>
			// Handle binary response (byte array).
			try {
<span class="nc" id="L699">				return (T) response.body().bytes();</span>
<span class="nc" id="L700">			} catch(IOException e) {</span>
<span class="nc" id="L701">				throw new ApiException(e);</span>
			}
<span class="nc bnc" id="L703" title="All 2 branches missed.">		} else if(returnType.equals(File.class)) {</span>
			// Handle file downloading.
<span class="nc" id="L705">			return (T) downloadFileFromResponse(response);</span>
		}

		String respBody;
		try {
<span class="nc bnc" id="L710" title="All 2 branches missed.">			if(response.body() != null)</span>
<span class="nc" id="L711">				respBody = response.body().string();</span>
			else
<span class="nc" id="L713">				respBody = null;</span>
<span class="nc" id="L714">		} catch(IOException e) {</span>
<span class="nc" id="L715">			throw new ApiException(e);</span>
<span class="nc" id="L716">		}</span>

<span class="nc bnc" id="L718" title="All 4 branches missed.">		if(respBody == null || &quot;&quot;.equals(respBody)) {</span>
<span class="nc" id="L719">			return null;</span>
		}

<span class="nc" id="L722">		String contentType = response.headers().get(&quot;Content-Type&quot;);</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">		if(contentType == null) {</span>
			// ensuring a default content type
<span class="nc" id="L725">			contentType = &quot;application/json&quot;;</span>
		}
<span class="nc bnc" id="L727" title="All 2 branches missed.">		if(isJsonMime(contentType)) {</span>
<span class="nc" id="L728">			return json.deserialize(respBody, returnType);</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">		} else if(returnType.equals(String.class)) {</span>
			// Expecting string, return the raw response body.
<span class="nc" id="L731">			return (T) respBody;</span>
		} else {
<span class="nc" id="L733">			throw new ApiException(&quot;Content type \&quot;&quot; + contentType + &quot;\&quot; is not supported for type: &quot; + returnType, response.code(), response.headers().toMultimap(), respBody);</span>
		}
	}

	/**
	 * Serialize the given Java object into request body according to the object's
	 * class and the request Content-Type.
	 *
	 * @param obj         The Java object
	 * @param contentType The request Content-Type
	 * @return The serialized request body
	 * @throws ApiException If fail to serialize the given object
	 */
	public RequestBody serialize(Object obj, String contentType) throws ApiException {
<span class="nc bnc" id="L747" title="All 2 branches missed.">		if(obj instanceof byte[]) {</span>
			// Binary (byte array) body parameter support.
<span class="nc" id="L749">			return RequestBody.create(MediaType.parse(contentType), (byte[]) obj);</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">		} else if(obj instanceof File) {</span>
			// File body parameter support.
<span class="nc" id="L752">			return RequestBody.create(MediaType.parse(contentType), (File) obj);</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">		} else if(isJsonMime(contentType)) {</span>
			String content;
<span class="nc bnc" id="L755" title="All 2 branches missed.">			if(obj != null) {</span>
<span class="nc" id="L756">				content = json.serialize(obj);</span>
			} else {
<span class="nc" id="L758">				content = null;</span>
			}
<span class="nc" id="L760">			return RequestBody.create(MediaType.parse(contentType), content);</span>
		} else {
<span class="nc" id="L762">			throw new ApiException(&quot;Content type \&quot;&quot; + contentType + &quot;\&quot; is not supported&quot;);</span>
		}
	}

	/**
	 * Download file from the given response.
	 *
	 * @param response An instance of the Response object
	 * @return Downloaded file
	 * @throws ApiException If fail to read file content from response and write to disk
	 */
	public File downloadFileFromResponse(Response response) throws ApiException {
		try {
<span class="nc" id="L775">			File file = prepareDownloadFile(response);</span>
<span class="nc" id="L776">			BufferedSink sink = Okio.buffer(Okio.sink(file));</span>
<span class="nc" id="L777">			sink.writeAll(response.body().source());</span>
<span class="nc" id="L778">			sink.close();</span>
<span class="nc" id="L779">			return file;</span>
<span class="nc" id="L780">		} catch(IOException e) {</span>
<span class="nc" id="L781">			throw new ApiException(e);</span>
		}
	}

	/**
	 * Prepare file for download
	 *
	 * @param response An instance of the Response object
	 * @return Prepared file for the download
	 * @throws IOException If fail to prepare file for download
	 */
	public File prepareDownloadFile(Response response) throws IOException {
<span class="nc" id="L793">		String filename = null;</span>
<span class="nc" id="L794">		String contentDisposition = response.header(&quot;Content-Disposition&quot;);</span>
<span class="nc bnc" id="L795" title="All 4 branches missed.">		if(contentDisposition != null &amp;&amp; !&quot;&quot;.equals(contentDisposition)) {</span>
			// Get filename from the Content-Disposition header.
<span class="nc" id="L797">			Pattern pattern = Pattern.compile(&quot;filename=['\&quot;]?([^'\&quot;\\s]+)['\&quot;]?&quot;);</span>
<span class="nc" id="L798">			Matcher matcher = pattern.matcher(contentDisposition);</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">			if(matcher.find()) {</span>
<span class="nc" id="L800">				filename = sanitizeFilename(matcher.group(1));</span>
			}
		}

<span class="nc" id="L804">		String prefix = null;</span>
<span class="nc" id="L805">		String suffix = null;</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">		if(filename == null) {</span>
<span class="nc" id="L807">			prefix = &quot;download-&quot;;</span>
<span class="nc" id="L808">			suffix = &quot;&quot;;</span>
		} else {
<span class="nc" id="L810">			int pos = filename.lastIndexOf(&quot;.&quot;);</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">			if(pos == -1) {</span>
<span class="nc" id="L812">				prefix = filename + &quot;-&quot;;</span>
			} else {
<span class="nc" id="L814">				prefix = filename.substring(0, pos) + &quot;-&quot;;</span>
<span class="nc" id="L815">				suffix = filename.substring(pos);</span>
			}
			// File.createTempFile requires the prefix to be at least three characters long
<span class="nc bnc" id="L818" title="All 2 branches missed.">			if(prefix.length() &lt; 3)</span>
<span class="nc" id="L819">				prefix = &quot;download-&quot;;</span>
		}

<span class="nc bnc" id="L822" title="All 2 branches missed.">		if(tempFolderPath == null)</span>
<span class="nc" id="L823">			return Files.createTempFile(prefix, suffix).toFile();</span>
		else
<span class="nc" id="L825">			return Files.createTempFile(Paths.get(tempFolderPath), prefix, suffix).toFile();</span>
	}

	/**
	 * {@link #execute(Call, Type)}
	 *
	 * @param &lt;T&gt;  Type
	 * @param call An instance of the Call object
	 * @return ApiResponse&amp;lt;T&amp;gt;
	 * @throws ApiException If fail to execute the call
	 */
	public &lt;T&gt; ApiResponse&lt;T&gt; execute(Call call) throws ApiException {
<span class="nc" id="L837">		return execute(call, null);</span>
	}

	/**
	 * Execute HTTP call and deserialize the HTTP response body into the given return type.
	 *
	 * @param returnType The return type used to deserialize HTTP response body
	 * @param &lt;T&gt;        The return type corresponding to (same with) returnType
	 * @param call       Call
	 * @return ApiResponse object containing response status, headers and
	 * data, which is a Java object deserialized from response body and would be null
	 * when returnType is null.
	 * @throws ApiException If fail to execute the call
	 */
	public &lt;T&gt; ApiResponse&lt;T&gt; execute(Call call, Type returnType) throws ApiException {
		try {
<span class="nc" id="L853">			Response response = call.execute();</span>
<span class="nc" id="L854">			T data = handleResponse(response, returnType);</span>
<span class="nc" id="L855">			return new ApiResponse&lt;T&gt;(response.code(), response.headers().toMultimap(), data);</span>
<span class="nc" id="L856">		} catch(IOException e) {</span>
<span class="nc" id="L857">			throw new ApiException(e);</span>
		}
	}

	/**
	 * {@link #executeAsync(Call, Type, ApiCallback)}
	 *
	 * @param &lt;T&gt;      Type
	 * @param call     An instance of the Call object
	 * @param callback ApiCallback&amp;lt;T&amp;gt;
	 */
	public &lt;T&gt; void executeAsync(Call call, ApiCallback&lt;T&gt; callback) {
<span class="nc" id="L869">		executeAsync(call, null, callback);</span>
<span class="nc" id="L870">	}</span>

	/**
	 * Execute HTTP call asynchronously.
	 *
	 * @param &lt;T&gt;        Type
	 * @param call       The callback to be executed when the API call finishes
	 * @param returnType Return type
	 * @param callback   ApiCallback
	 * @see #execute(Call, Type)
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;T&gt; void executeAsync(Call call, final Type returnType, final ApiCallback&lt;T&gt; callback) {
<span class="nc" id="L883">		call.enqueue(new Callback() {</span>
			@Override
			public void onFailure(Request request, IOException e) {
<span class="nc" id="L886">				callback.onFailure(new ApiException(e), 0, null);</span>
<span class="nc" id="L887">			}</span>

			@Override
			public void onResponse(Response response) throws IOException {
				T result;
				try {
<span class="nc" id="L893">					result = handleResponse(response, returnType);</span>
<span class="nc" id="L894">				} catch(ApiException e) {</span>
<span class="nc" id="L895">					callback.onFailure(e, response.code(), response.headers().toMultimap());</span>
<span class="nc" id="L896">					return;</span>
<span class="nc" id="L897">				}</span>
<span class="nc" id="L898">				callback.onSuccess(result, response.code(), response.headers().toMultimap());</span>
<span class="nc" id="L899">			}</span>
		});
<span class="nc" id="L901">	}</span>

	/**
	 * Handle the given response, return the deserialized object when the response is successful.
	 *
	 * @param &lt;T&gt;        Type
	 * @param response   Response
	 * @param returnType Return type
	 * @return Type
	 * @throws ApiException If the response has a unsuccessful status code or
	 *                      fail to deserialize the response body
	 */
	public &lt;T&gt; T handleResponse(Response response, Type returnType) throws ApiException {
<span class="nc bnc" id="L914" title="All 2 branches missed.">		if(response.isSuccessful()) {</span>
<span class="nc bnc" id="L915" title="All 4 branches missed.">			if(returnType == null || response.code() == 204) {</span>
				// returning null if the returnType is not defined,
				// or the status code is 204 (No Content)
<span class="nc bnc" id="L918" title="All 2 branches missed.">				if(response.body() != null) {</span>
					try {
<span class="nc" id="L920">						response.body().close();</span>
<span class="nc" id="L921">					} catch(IOException e) {</span>
<span class="nc" id="L922">						throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());</span>
<span class="nc" id="L923">					}</span>
				}
<span class="nc" id="L925">				return null;</span>
			} else {
<span class="nc" id="L927">				return deserialize(response, returnType);</span>
			}
		} else {
<span class="nc" id="L930">			String respBody = null;</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">			if(response.body() != null) {</span>
				try {
<span class="nc" id="L933">					respBody = response.body().string();</span>
<span class="nc" id="L934">				} catch(IOException e) {</span>
<span class="nc" id="L935">					throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());</span>
<span class="nc" id="L936">				}</span>
			}
<span class="nc" id="L938">			throw new ApiException(response.message(), response.code(), response.headers().toMultimap(), respBody);</span>
		}
	}

	/**
	 * Build HTTP call with the given options.
	 *
	 * @param path                    The sub-path of the HTTP URL
	 * @param method                  The request method, one of &quot;GET&quot;, &quot;HEAD&quot;, &quot;OPTIONS&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;PATCH&quot; and &quot;DELETE&quot;
	 * @param queryParams             The query parameters
	 * @param collectionQueryParams   The collection query parameters
	 * @param body                    The request body object
	 * @param headerParams            The header parameters
	 * @param formParams              The form parameters
	 * @param authNames               The authentications to apply
	 * @param progressRequestListener Progress request listener
	 * @return The HTTP call
	 * @throws ApiException If fail to serialize the request body object
	 */
	public Call buildCall(String path, String method, List&lt;Pair&gt; queryParams, List&lt;Pair&gt; collectionQueryParams, Object body, Map&lt;String, String&gt; headerParams, Map&lt;String, Object&gt; formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
<span class="nc" id="L958">		Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, progressRequestListener);</span>

<span class="nc" id="L960">		return httpClient.newCall(request);</span>
	}

	/**
	 * Build an HTTP request with the given options.
	 *
	 * @param path                    The sub-path of the HTTP URL
	 * @param method                  The request method, one of &quot;GET&quot;, &quot;HEAD&quot;, &quot;OPTIONS&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;PATCH&quot; and &quot;DELETE&quot;
	 * @param queryParams             The query parameters
	 * @param collectionQueryParams   The collection query parameters
	 * @param body                    The request body object
	 * @param headerParams            The header parameters
	 * @param formParams              The form parameters
	 * @param authNames               The authentications to apply
	 * @param progressRequestListener Progress request listener
	 * @return The HTTP request
	 * @throws ApiException If fail to serialize the request body object
	 */
	public Request buildRequest(String path, String method, List&lt;Pair&gt; queryParams, List&lt;Pair&gt; collectionQueryParams, Object body, Map&lt;String, String&gt; headerParams, Map&lt;String, Object&gt; formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
<span class="nc" id="L979">		updateParamsForAuth(authNames, queryParams, headerParams);</span>

<span class="nc" id="L981">		final String url = buildUrl(path, queryParams, collectionQueryParams);</span>
<span class="nc" id="L982">		final Request.Builder reqBuilder = new Request.Builder().url(url);</span>
<span class="nc" id="L983">		processHeaderParams(headerParams, reqBuilder);</span>

<span class="nc" id="L985">		String contentType = headerParams.get(&quot;Content-Type&quot;);</span>
		// ensuring a default content type
<span class="nc bnc" id="L987" title="All 2 branches missed.">		if(contentType == null) {</span>
<span class="nc" id="L988">			contentType = &quot;application/json&quot;;</span>
		}

		RequestBody reqBody;
<span class="nc bnc" id="L992" title="All 2 branches missed.">		if(!HttpMethod.permitsRequestBody(method)) {</span>
<span class="nc" id="L993">			reqBody = null;</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">		} else if(&quot;application/x-www-form-urlencoded&quot;.equals(contentType)) {</span>
<span class="nc" id="L995">			reqBody = buildRequestBodyFormEncoding(formParams);</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">		} else if(&quot;multipart/form-data&quot;.equals(contentType)) {</span>
<span class="nc" id="L997">			reqBody = buildRequestBodyMultipart(formParams);</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">		} else if(body == null) {</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">			if(&quot;DELETE&quot;.equals(method)) {</span>
				// allow calling DELETE without sending a request body
<span class="nc" id="L1001">				reqBody = null;</span>
			} else {
				// use an empty request body (for POST, PUT and PATCH)
<span class="nc" id="L1004">				reqBody = RequestBody.create(MediaType.parse(contentType), &quot;&quot;);</span>
			}
		} else {
<span class="nc" id="L1007">			reqBody = serialize(body, contentType);</span>
		}

<span class="nc" id="L1010">		Request request = null;</span>

<span class="nc bnc" id="L1012" title="All 4 branches missed.">		if(progressRequestListener != null &amp;&amp; reqBody != null) {</span>
<span class="nc" id="L1013">			ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);</span>
<span class="nc" id="L1014">			request = reqBuilder.method(method, progressRequestBody).build();</span>
<span class="nc" id="L1015">		} else {</span>
<span class="nc" id="L1016">			request = reqBuilder.method(method, reqBody).build();</span>
		}

<span class="nc" id="L1019">		return request;</span>
	}

	/**
	 * Build full URL by concatenating base path, the given sub path and query parameters.
	 *
	 * @param path                  The sub path
	 * @param queryParams           The query parameters
	 * @param collectionQueryParams The collection query parameters
	 * @return The full URL
	 */
	public String buildUrl(String path, List&lt;Pair&gt; queryParams, List&lt;Pair&gt; collectionQueryParams) {
<span class="nc" id="L1031">		final StringBuilder url = new StringBuilder();</span>
<span class="nc" id="L1032">		url.append(basePath).append(path);</span>

<span class="nc bnc" id="L1034" title="All 4 branches missed.">		if(queryParams != null &amp;&amp; !queryParams.isEmpty()) {</span>
			// support (constant) query string in `path`, e.g. &quot;/posts?draft=1&quot;
<span class="nc bnc" id="L1036" title="All 2 branches missed.">			String prefix = path.contains(&quot;?&quot;) ? &quot;&amp;&quot; : &quot;?&quot;;</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">			for(Pair param : queryParams) {</span>
<span class="nc bnc" id="L1038" title="All 2 branches missed.">				if(param.getValue() != null) {</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">					if(prefix != null) {</span>
<span class="nc" id="L1040">						url.append(prefix);</span>
<span class="nc" id="L1041">						prefix = null;</span>
					} else {
<span class="nc" id="L1043">						url.append(&quot;&amp;&quot;);</span>
					}
<span class="nc" id="L1045">					String value = parameterToString(param.getValue());</span>
<span class="nc" id="L1046">					url.append(escapeString(param.getName())).append(&quot;=&quot;).append(escapeString(value));</span>
				}
<span class="nc" id="L1048">			}</span>
		}

<span class="nc bnc" id="L1051" title="All 4 branches missed.">		if(collectionQueryParams != null &amp;&amp; !collectionQueryParams.isEmpty()) {</span>
<span class="nc bnc" id="L1052" title="All 2 branches missed.">			String prefix = url.toString().contains(&quot;?&quot;) ? &quot;&amp;&quot; : &quot;?&quot;;</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">			for(Pair param : collectionQueryParams) {</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">				if(param.getValue() != null) {</span>
<span class="nc bnc" id="L1055" title="All 2 branches missed.">					if(prefix != null) {</span>
<span class="nc" id="L1056">						url.append(prefix);</span>
<span class="nc" id="L1057">						prefix = null;</span>
					} else {
<span class="nc" id="L1059">						url.append(&quot;&amp;&quot;);</span>
					}
<span class="nc" id="L1061">					String value = parameterToString(param.getValue());</span>
					// collection query parameter value already escaped as part of parameterToPairs
<span class="nc" id="L1063">					url.append(escapeString(param.getName())).append(&quot;=&quot;).append(value);</span>
				}
<span class="nc" id="L1065">			}</span>
		}

<span class="nc" id="L1068">		return url.toString();</span>
	}

	/**
	 * Set header parameters to the request builder, including default headers.
	 *
	 * @param headerParams Header parameters in the ofrm of Map
	 * @param reqBuilder   Reqeust.Builder
	 */
	public void processHeaderParams(Map&lt;String, String&gt; headerParams, Request.Builder reqBuilder) {
<span class="nc bnc" id="L1078" title="All 2 branches missed.">		for(Entry&lt;String, String&gt; param : headerParams.entrySet()) {</span>
<span class="nc" id="L1079">			reqBuilder.header(param.getKey(), parameterToString(param.getValue()));</span>
<span class="nc" id="L1080">		}</span>
<span class="nc bnc" id="L1081" title="All 2 branches missed.">		for(Entry&lt;String, String&gt; header : defaultHeaderMap.entrySet()) {</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">			if(!headerParams.containsKey(header.getKey())) {</span>
<span class="nc" id="L1083">				reqBuilder.header(header.getKey(), parameterToString(header.getValue()));</span>
			}
<span class="nc" id="L1085">		}</span>
<span class="nc" id="L1086">	}</span>

	/**
	 * Update query and header parameters based on authentication settings.
	 *
	 * @param authNames    The authentications to apply
	 * @param queryParams  List of query parameters
	 * @param headerParams Map of header parameters
	 */
	public void updateParamsForAuth(String[] authNames, List&lt;Pair&gt; queryParams, Map&lt;String, String&gt; headerParams) {
<span class="nc bnc" id="L1096" title="All 2 branches missed.">		for(String authName : authNames) {</span>
<span class="nc" id="L1097">			Authentication auth = authentications.get(authName);</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">			if(auth == null)</span>
<span class="nc" id="L1099">				throw new RuntimeException(&quot;Authentication undefined: &quot; + authName);</span>
<span class="nc" id="L1100">			auth.applyToParams(queryParams, headerParams);</span>
		}
<span class="nc" id="L1102">	}</span>

	/**
	 * Build a form-encoding request body with the given form parameters.
	 *
	 * @param formParams Form parameters in the form of Map
	 * @return RequestBody
	 */
	public RequestBody buildRequestBodyFormEncoding(Map&lt;String, Object&gt; formParams) {
<span class="nc" id="L1111">		FormEncodingBuilder formBuilder = new FormEncodingBuilder();</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">		for(Entry&lt;String, Object&gt; param : formParams.entrySet()) {</span>
<span class="nc" id="L1113">			formBuilder.add(param.getKey(), parameterToString(param.getValue()));</span>
<span class="nc" id="L1114">		}</span>
<span class="nc" id="L1115">		return formBuilder.build();</span>
	}

	/**
	 * Build a multipart (file uploading) request body with the given form parameters,
	 * which could contain text fields and file fields.
	 *
	 * @param formParams Form parameters in the form of Map
	 * @return RequestBody
	 */
	public RequestBody buildRequestBodyMultipart(Map&lt;String, Object&gt; formParams) {
<span class="nc" id="L1126">		MultipartBuilder mpBuilder = new MultipartBuilder().type(MultipartBuilder.FORM);</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">		for(Entry&lt;String, Object&gt; param : formParams.entrySet()) {</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">			if(param.getValue() instanceof File file) {</span>
<span class="nc" id="L1129">				Headers partHeaders = Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\&quot;&quot; + param.getKey() + &quot;\&quot;; filename=\&quot;&quot; + file.getName() + &quot;\&quot;&quot;);</span>
<span class="nc" id="L1130">				MediaType mediaType = MediaType.parse(guessContentTypeFromFile(file));</span>
<span class="nc" id="L1131">				mpBuilder.addPart(partHeaders, RequestBody.create(mediaType, file));</span>
<span class="nc" id="L1132">			} else {</span>
<span class="nc" id="L1133">				Headers partHeaders = Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\&quot;&quot; + param.getKey() + &quot;\&quot;&quot;);</span>
<span class="nc" id="L1134">				mpBuilder.addPart(partHeaders, RequestBody.create(null, parameterToString(param.getValue())));</span>
			}
<span class="nc" id="L1136">		}</span>
<span class="nc" id="L1137">		return mpBuilder.build();</span>
	}

	/**
	 * Guess Content-Type header from the given file (defaults to &quot;application/octet-stream&quot;).
	 *
	 * @param file The given file
	 * @return The guessed Content-Type
	 */
	public String guessContentTypeFromFile(File file) {
<span class="nc" id="L1147">		String contentType = URLConnection.guessContentTypeFromName(file.getName());</span>
<span class="nc bnc" id="L1148" title="All 2 branches missed.">		if(contentType == null) {</span>
<span class="nc" id="L1149">			return &quot;application/octet-stream&quot;;</span>
		} else {
<span class="nc" id="L1151">			return contentType;</span>
		}
	}

	/**
	 * Apply SSL related settings to httpClient according to the current values of
	 * verifyingSsl and sslCaCert.
	 */
	private void applySslSettings() {
		try {
<span class="nc" id="L1161">			TrustManager[] trustManagers = null;</span>
<span class="nc" id="L1162">			HostnameVerifier hostnameVerifier = null;</span>
<span class="nc bnc" id="L1163" title="All 2 branches missed.">			if(!verifyingSsl) {</span>
<span class="nc" id="L1164">				TrustManager trustAll = new X509TrustManager() {</span>
					@Override
					public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
<span class="nc" id="L1167">					}</span>

					@Override
					public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
<span class="nc" id="L1171">					}</span>

					@Override
					public X509Certificate[] getAcceptedIssuers() {
<span class="nc" id="L1175">						return null;</span>
					}
				};
<span class="nc" id="L1178">				SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</span>
<span class="nc" id="L1179">				trustManagers = new TrustManager[]{trustAll};</span>
<span class="nc" id="L1180">				hostnameVerifier = new HostnameVerifier() {</span>
					@Override
					public boolean verify(String hostname, SSLSession session) {
<span class="nc" id="L1183">						return true;</span>
					}
				};
<span class="nc bnc" id="L1186" title="All 2 branches missed.">			} else if(sslCaCert != null) {</span>
<span class="nc" id="L1187">				char[] password = null; // Any password will work.</span>
<span class="nc" id="L1188">				CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;);</span>
<span class="nc" id="L1189">				Collection&lt;? extends Certificate&gt; certificates = certificateFactory.generateCertificates(sslCaCert);</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">				if(certificates.isEmpty()) {</span>
<span class="nc" id="L1191">					throw new IllegalArgumentException(&quot;expected non-empty set of trusted certificates&quot;);</span>
				}
<span class="nc" id="L1193">				KeyStore caKeyStore = newEmptyKeyStore(password);</span>
<span class="nc" id="L1194">				int index = 0;</span>
<span class="nc bnc" id="L1195" title="All 2 branches missed.">				for(Certificate certificate : certificates) {</span>
<span class="nc" id="L1196">					String certificateAlias = &quot;ca&quot; + index++;</span>
<span class="nc" id="L1197">					caKeyStore.setCertificateEntry(certificateAlias, certificate);</span>
<span class="nc" id="L1198">				}</span>
<span class="nc" id="L1199">				TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span>
<span class="nc" id="L1200">				trustManagerFactory.init(caKeyStore);</span>
<span class="nc" id="L1201">				trustManagers = trustManagerFactory.getTrustManagers();</span>
			}

<span class="nc bnc" id="L1204" title="All 4 branches missed.">			if(keyManagers != null || trustManagers != null) {</span>
<span class="nc" id="L1205">				SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</span>
<span class="nc" id="L1206">				sslContext.init(keyManagers, trustManagers, new SecureRandom());</span>
<span class="nc" id="L1207">				httpClient.setSslSocketFactory(sslContext.getSocketFactory());</span>
<span class="nc" id="L1208">			} else {</span>
<span class="nc" id="L1209">				httpClient.setSslSocketFactory(null);</span>
			}
<span class="nc" id="L1211">			httpClient.setHostnameVerifier(hostnameVerifier);</span>
<span class="nc" id="L1212">		} catch(GeneralSecurityException e) {</span>
<span class="nc" id="L1213">			throw new RuntimeException(e);</span>
<span class="nc" id="L1214">		}</span>
<span class="nc" id="L1215">	}</span>

	private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
		try {
<span class="nc" id="L1219">			KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());</span>
<span class="nc" id="L1220">			keyStore.load(null, password);</span>
<span class="nc" id="L1221">			return keyStore;</span>
<span class="nc" id="L1222">		} catch(IOException e) {</span>
<span class="nc" id="L1223">			throw new AssertionError(e);</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>